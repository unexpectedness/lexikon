<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>lexikon.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Lexikon</span> <span class="project-version">0.2.2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="lexikon.core.html"><div class="inner"><span>lexikon.core</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="lexikon.core.html#var-*warn-on-late-eval*"><div class="inner"><span>*warn-on-late-eval*</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-binding-context"><div class="inner"><span>binding-context</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-context"><div class="inner"><span>context</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-context.21"><div class="inner"><span>context!</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-contexts"><div class="inner"><span>contexts</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-delete-context.21"><div class="inner"><span>delete-context!</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-letmap"><div class="inner"><span>letmap</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-lexical-context"><div class="inner"><span>lexical-context</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-lexical-eval"><div class="inner"><span>lexical-eval</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-lexical-map"><div class="inner"><span>lexical-map</span></div></a></li><li class="depth-1"><a href="lexikon.core.html#var-lexical-resolve"><div class="inner"><span>lexical-resolve</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">lexikon.core</h1><div class="doc"><div class="markdown"></div></div><div class="public anchor" id="var-*warn-on-late-eval*"><h3>*warn-on-late-eval*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-binding-context"><h3>binding-context</h3><h4 class="type">macro</h4><div class="usage"><code>(binding-context k &amp; body)</code></div><div class="doc"><div class="markdown"><p>Retrieves a stored lexical context from memory and binds it using <code>let</code>.</p>
<pre><code class="language-clojure">(context! :k {'a 1})

(binding-context :k
  (inc a))
=&gt; 2

Note: you can only bind a context if its key is known at compile time.
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-context"><h3>context</h3><div class="usage"><code>(context k)</code><code>(context k kk)</code></div><div class="doc"><div class="markdown"><p>Fetches a map stored in memory under key <code>k</code>. If <code>kk</code> is provided, fetches <code>kk</code> in <code>k</code>.</p>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-context.21"><h3>context!</h3><div class="usage"><code>(context! k key value)</code><code>(context! k ctx)</code></div><div class="doc"><div class="markdown"><p>Stores a map in memory under key <code>k</code>. Merges with the previous context if present.</p>
<pre><code class="language-clojure">(context! :k {'a 123})
(context! :k 'b 456)

(context :k)
=&gt; {'a 123 'b 456}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-contexts"><h3>contexts</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The global store for contexts. An atom containing a map of maps: <code>{key -&gt; {symbol -&gt; value}}</code></p>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-delete-context.21"><h3>delete-context!</h3><div class="usage"><code>(delete-context! k)</code></div><div class="doc"><div class="markdown"><p>Deletes the map stored in memory under key <code>k</code>.</p>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-letmap"><h3>letmap</h3><h4 class="type">macro</h4><div class="usage"><code>(letmap m &amp; body)</code></div><div class="doc"><div class="markdown"><p>Binds each key of <code>m</code> to the corresponding value. Keys in <code>m</code> must be litteral symbols. If <code>m</code> is not a litteral map nor a macro that expands to one, <code>lexical-eval</code> will be used at runtime. However this will print a warning. Set <code>*warn-on-late-eval*</code> to false to silence it. <code>m</code> can be quoted or not.</p>
<pre><code class="language-clojure">(letmap '{a 1 b 2}
  [a b])
=&gt; [1 2]
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-lexical-context"><h3>lexical-context</h3><h4 class="type">macro</h4><div class="usage"><code>(lexical-context &amp; {:as opts})</code></div><div class="doc"><div class="markdown"><p>Returns the current lexical context as a map from symbols to values. In macros (or anywhere <code>&amp;env</code> is a local in scope), <code>lexical-context</code> will expand to code that will return the context of the expanded form rather than the context of the macro itself. Use <code>(lexical-context :local true)</code> to override this behavior.</p>
<p>You can also use the <code>:keys</code> and <code>:vals</code> options to specify how they should be processed (possible values: <code>:quoted</code>, <code>:doubly-quoted</code> or <code>:evaled</code>).</p>
<pre><code class="language-clojure">(let [a 1 b 2 c 3]
  (lexical-context))
=&gt; {'a 1 'b 2 'c 3}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-lexical-eval"><h3>lexical-eval</h3><h4 class="type">macro</h4><div class="usage"><code>(lexical-eval code)</code><code>(lexical-eval ctx code)</code></div><div class="doc"><div class="markdown"><p>Evaluates code in the given lexical context. If no context is passed, <a href="lexikon.core.html#var-lexical-context">lexical-context</a> is used.</p>
<pre><code class="language-clojure">(let [a 1]                  ; CompilerException:
  (eval '(inc a))           ; Unable to resolve symbol: a in this context

  (lexical-eval (inc a))    ; =&gt; 2
  (lexical-eval {'a 22} a)) ; =&gt; 22
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-lexical-map"><h3>lexical-map</h3><h4 class="type">macro</h4><div class="usage"><code>(lexical-map &amp; args)</code></div><div class="doc"><div class="markdown"><p>Turns a collection of symbols into a map of symbols to their value in the current lexical context. If <code>params</code> is not a litteral nor expands to one, <code>lexical-eval</code> will be used at runtime. However this will print a warning. Set <code>*warn-on-late-eval*</code> to false to silence it.</p>
<pre><code class="language-clojure">(let [a 1 b 2 c 3]
  (lexical-map '[a b])                 ; =&gt; {'a 1 'b 2}
  (lexical-map '[a b] :keywords true)) ; =&gt; {:a 1 :b 2}
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div><div class="public anchor" id="var-lexical-resolve"><h3>lexical-resolve</h3><h4 class="type">macro</h4><div class="usage"><code>(lexical-resolve x)</code><code>(lexical-resolve lex x)</code></div><div class="doc"><div class="markdown"><p>Resolve symbol in the current or given lexical context.</p>
</div></div><div class="src-link"><a href="https://github.com/unexpectedness/threading/">view source</a></div></div></div></body></html>